\chapter{Design}
This chapter discusses the design process of our application. First, it was needed to know what the user requirements are. For this, we interviewed our supervisor who also acts as our client. These requirements were also acquired through brainstorming. Then, use cases for our application were designed, which corresponds with the user requirements. In this phase, a business class diagram was also made which is easier to understand for the client than the complete class diagram of the whole application. After researching the framework present on the Samsung Smart TV and the possibilities of libswift, a design for the software architecture could be made. Lastly, implementation models such as sequence diagrams and class diagrams were made, which serve as blueprints for the application.

\section{Requirements}
The requirements can be split in two kinds, functional and non-functional requirements. These requirements  correspond to the use cases as mentioned in section \hyperref[sec:use_cases]{\ref*{sec:use_cases}} The non-functional requirements can then again be split in quality and platform requirements. In this section, the constraints the application has to deal with are also discussed.

\subsection{Functional requirements} 
Functional requirements specify the core functionality of the application. These requirements are covered by the use cases in the next section. The functional requirements are as follows:

\begin{itemize}
\item[1.] Given two peers \textit{A} and \textit{B}:
	\begin{itemize}
	\item[1.1.] \textit{A} is able to download from \textit{B} (UC 12);
	\item[1.2.] \textit{A} is able to upload to \textit{B} (No use case since this should happen automatically);
	\item[1.3.] \textit{A} is able to stream to/from \textit{B} (UC 11);
	\end{itemize}	
\item[2.] The users should be able to search for files other peers own (UC 9, 13);
\item[3.] The users should be able to search/browse files they own themselves (UC 2, 8, 13);
\item[4.] The users should be able to playback media content. Media in this context means any kind of video or audio file (UC 6);
\item[5.] Users should be able to:
	\begin{itemize}
	\item[5.1.] Move files on the file system (UC 5);
	\item[5.2.] Edit files on the file system, i.e. rename files (UC 3);	
	\item[5.3.] Remove files on the file system (UC 4);
	
	\end{itemize}	 
\item[6.] Users should be able to sort files by name, size, date and type (UC 10, 14, 15, 16, 17); 
\item[7.] Users should be able to separate private files from public files (UC 7);
\item[8.] Users should be able to limit the upload/download speed (UC 1). 
\end{itemize} 

\subsection{Non-functional requirements}
Non-functional requirements are those requirements that have to do with the operation of the system. Unlike functional requirements, they do not describe what the services the system should provide, but more how the system should work. We identified two kinds of non-functional requirements for our application, quality and platform requirements.

\subsubsection{Quality requirements} 
\begin{itemize}
\item[1] The response time of the system should be as low as possible since TVs are real-time systems. We aim to limit the response time to 300 ms;
\item[2] The RAM memory used by the application should not exceed 256 MB. This includes the size of the application itself and the memory needed for calculations;
\item[3] The application may use 100\% CPU power since no other applications should run along the application to be built;
\item[4] Downloads should be continued without loss of data after a failure;
\item[5] Unfinished downloads should be resumed at start up;
\item[6] The application should be able to cope with external devices, memory sticks and other external storage devices in particular;
\item[7] The user should be able to make use of (part of) the application at any time, even when no Internet connection is available.  
\end{itemize} 

\subsubsection{Platform requirements}
\begin{itemize}
\item[1] The C++ back-end which makes use of the libswift library should be implemented so that it is reusable for other systems that work with other front-ends (such as Android);
\item[2] The application is made to run on a rooted Samsung Smart TV. To see whether a Samsung TV is rootable or not, please check \url{http://www.samygo.tv/};
\end{itemize}

\subsection{Constraints}
The constraints specify what our own limitations are we have to take into account when implementing the application. These can be limitations put by the software we use, or put by ourselves to reduce the application\textquotesingle s complexity.

\begin{itemize}
\item[1] Due to the limited memory available on the TV, it is not 
possible to download and store great amounts of data on the TV. 
Therefore, usage of external storage devices is mandatory to make use 
of the application;

\item[2] The application must be integrated with the Samsung 
framework, meaning that it should be recognised by the TV as 
JavaScript app developed with the Samsung SDK.
\end{itemize}

\section{Use Cases}
\label{sec:use_cases}
\begin{center}
\begin{figure}[h!]
\begin{tikzpicture}
\begin{umlsystem}[fill=red!10]{The system}

\umlusecase[x=6, width=4cm]{1.Limit upload/download speed}
\umlusecase[x=-2, y=-4, width=1.5cm]{3.Update Files}
\umlusecase[x=1, y=-3, width=1.5cm]{4.Delete Files}
\umlusecase[x=7, y=-2, width=3cm]{6.Play Media File}
\umlusecase[width=3cm]{2.Browse File System}
\umlusecase[x=4, y=-4, width=1.5cm]{5.Move Files}
\umlusecase[x=7, y=-9, width =1.5cm]{11.Stream File}
\umlusecase[x=7, y=-11, width =1.5cm]{12.Download File}
\umlusecase[x=8, y=-4, width=3cm]{7.Change File Visibility}
\umlusecase[y=-10, width=1.5cm]{10.Sort Files}
\umlusecase[x=-1, y=-7, width=1.5cm]{8.Search locally}
\umlusecase[x=2, y=-7, width=1.5cm]{9.Search on the net}
\umlusecase[x=3, y=-10, width=1.5cm]{13.Search File}
\umlusecase[x=-2, y=-14, width=1.5cm]{14.Sort on date}
\umlusecase[x=0, y=-14, width=1.5cm]{15.Sort on type}
\umlusecase[x=2, y=-14, width=1.5cm]{16.Sort on name}
\umlusecase[x=4, y=-14, width=1.5cm]{17.Sort on size}

\end{umlsystem}

\umlactor[x=-4.5, y=-5]{User}

\umlinclude[name=incl]{usecase-7}{usecase-12}
\umlinclude[name=incl]{usecase-8}{usecase-12}

\umlinclude[name=incl]{usecase-9}{usecase-5}
\umlinclude[name=incl]{usecase-2}{usecase-5}
\umlinclude[name=incl]{usecase-3}{usecase-5}
\umlinclude[name=incl]{usecase-4}{usecase-5}
\umlinclude[name=incl]{usecase-6}{usecase-5}
\umlHVinclude[name=incl]{usecase-10}{usecase-5}

\umlinclude[name=incl]{usecase-2}{usecase-11}
\umlinclude[name=incl]{usecase-3}{usecase-11}
\umlinclude[name=incl]{usecase-6}{usecase-11}
\umlinclude[name=incl]{usecase-9}{usecase-11}

\umlVHVextend{usecase-14}{usecase-10}
\umlVHVextend{usecase-15}{usecase-10}
\umlVHVextend{usecase-16}{usecase-10}
\umlVHVextend{usecase-17}{usecase-10}

\umlVHVextend{usecase-11}{usecase-13}
\umlVHVextend{usecase-12}{usecase-13}

\end{tikzpicture}
\caption{Use case diagram of the application to be built. Note that the associations from the user to the use cases are left out in order to keep the diagram clear.}
\end{figure}
\end{center}

\clearpage
\section{Business Class Diagram}

\begin{center}
\begin{figure}[h!]
\begin{tikzpicture}
%\begin{umlpackage}{p}
%\begin{umlpackage}{sp1}

\umlclass[x=-5]{Sendable}{
  - trackers : list<tracker> \\
  - seeders  : list<seeder> \\
  - speed	   : double
}{
  + stop() : void \\
  + pause() : void \\
}

\umlclass[x=3]{FileManager}{
  - list<File>
}{
  + remove(File file) : void \\
  + add(File file) : File \\		
  + rename(File file) : File \\
  + sort() : void \\
  + search(File file) : list<File> \\
}

\umlclass[x=3, y=-6]{File}{
  - name : String \\
  - date : String \\  
  - extension : String \\  
  - size : double \\
  - visible : bool \\
}{
  + setVisibility(bool value); \\
  + isVisible() : bool;
}

\umlclass[x=4, y=-11]{Media}{
  - length : double \\
   
}{}

\umlclass[x=0, y=-11]{Picture}{
  - height : double \\
  - width  : double \\
}{}

\umlclass[x=-7, y=-4]{Download}{
  - percentage : double
}{
  + start() : void \\		
  + resume() : void \\  
}

\umlclass[x=-3, y=-4]{Upload}{
  - amount : double
}{
  + start() : void \\		
  + resume() : void \\  	
}

\umlclass[x=-5, y=-6]{Stream}{
  - amount : double
}{
  + play() : void
}

\umlclass[x=-5, y=-10.5]{DownloadManager}{
  - amount : double
}{
  + play() : void
}

\umlclass[x=-2, y=-14]{MediaPlayer}{
}{
  + open(Media file) : void \\
  + open(Stream stream) : void
}

\umlaggreg[mult1=1, mult2=1, pos=0.8, angle1=30, angle2=60]{Sendable}{File}
\umlaggreg[mult1=1, mult2=*]{FileManager}{File}

\umlVHVinherit{Download}{Sendable}
\umlVHVinherit{Upload}{Sendable}
\umlinherit{Stream}{Sendable}

\umlVHVinherit{Media}{File}
\umlVHVinherit{Picture}{File}

\umlVHVaggreg[mult1=1, mult2=*]{DownloadManager}{Upload}
\umlVHVaggreg[mult1=1, mult2=*]{DownloadManager}{Download}

\umlVHassoc{MediaPlayer}{Stream}
\umlVHassoc{Media}{MediaPlayer}

\end{tikzpicture}
\caption{Part of the class diagram. This part only depicts the business classes comprehensible for non-programmers.}
\end{figure}
\end{center}
\clearpage
\section{MosCoW}

\section{Software Architecture}

\section{Implementation}