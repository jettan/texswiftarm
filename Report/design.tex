\chapter{Design}
This chapter describes the design of the application to be built, this design is based on the requirements gathered previously. The design has to incorporate solutions to the problems mentioned in section Problems. %reference
This means the design has to include classes for a C++ backend using swift, a Javascript front end, a sandbox workaround and a means for inter-tv communication. First we'll discuss the current software archictecture on the tv. Then we'll discuss an extended version of this architecture which will allow us to implement solutions for the aforementioned problems. Finally the class diagram and other UML models will be discussed.

\section{Software Architecture}
As mentioned before in section Problems % hier reference 
the Samsung SDK for the Smart TV only allows programmers to create applications using HTML, CSS, Javascript and Flash.
All operations to be performed in the root file system will go via the SDK as a middle layer between our app and the root file system.
% Hier plaatje van standaard situatie

\section{Extended Software architecture}
The solution for being able to run C++ code has already been mentioned, namely getting root acces to the tv. This was already done in the orientation fase of this project. This leaves only one problem, the sandbox. The frontend and backend of our application need a way to communicate. Since one can't perform direct calls from Javascript to C++, we decided to use a networking approach. In Javascript it is possible to send HTTP GET messages to any server and since we already have root access we implemented our own HTTP web server written in C++. This way one can make a bridge between Javascript and C++ resulting in the ability to do C++ function calls from Javascript. Since the TV does not support HTML5 we weren't able to use websockets who provide an open connection in which a reply can be received asynchronously at any time. We are restricted to a client-server architecture where you have to keep polling for an update value for example. This however is sufficient for out matter. % Hier vertellen over dispery
%Hier plaatje van onze software architecture

\section{Class Diagram}
Figure \ref{fig:class_server} shows the class diagram for the webserver. These classes are then explained in more detail.

\begin{center}
\begin{figure}[h!]
\begin{tikzpicture}
%\begin{umlpackage}{p}
%\begin{umlpackage}{sp1}

\umlclass[x=-10]{Download}{
  - tracker : char* \\
  - seeders : int \\
  - peers : int \\
  - ratio : double \\
  - download\_speed : double \\
  - size : double \\
  - upload\_speed : double \\
  - download\_percentage : double \\
  - upload\_amount : double \\
  - status : Status
}{
  + start() : void \\
  + resume() : void \\
  + pause() : void
}

\umlclass[x=-1.5, y=-12]{Stream}{
  - tracker : char* \\
  - status : Status
}{
  + start() : void \\
  + resume() : void \\
  + pause() : void \\
  + stop() : void
}
\umlclass[x=-10, y=-12]{DownloadManager}{
  - downloaded : double \\
  - uploaded : double \\
  - downloads : list<Download> \\
  - uploads : list<Download> \\
}{
  + startStreaming() : bool \\
  + stopStreaming() : bool \\
  + stream() : void \\
  + add(Download download) : void \\
  + removeFromList(int download\_id) : void \\
  + removeFromDisk(int download\_id) : void \\
  + setSpeed(double dspeed, double uspeed)
}

\umlclass[x=-3, y=-6]{HttpServer}{
}{
  + InstallHTTPGateway() : bool \\
  + sendResponse() : void \\
  + sendXMLResponse() : void \\
  + handle\_request(struct evhttp\_request *req, void *arg) : void \\
  + init() : void
}

\umlclass[x=-0.5, y = 2]{SearchEngine}{
}{
  + search(char* filename) : void \\
  + getResults() : char*
}

\umlVHassoc[mult1=1, mult2=*]{HttpServer}{Download}
\umlassoc[mult1=1, mult2=1]{HttpServer}{DownloadManager}
\umlVHassoc[mult1=1, mult2=1]{SearchEngine}{HttpServer}

\umlaggreg[mult1=1, mult2=*]{DownloadManager}{Download}
\umlaggreg[mult1=1, mult2=1]{DownloadManager}{Stream}

\end{tikzpicture}
\label{fig:class_server}
\caption{Class diagram for the server.}
\end{figure}
\end{center}
\clearpage

\subsection{HttpServer}
This class listens to the requests coming from the web application.
It will then call methods from either SearchEngine or DownloadManager, depending on what the request is. As response, either a confirmation
is sent or the return value of the called methods is sent. The class can be seen as the main controller of the system
since all logic happens here. This class is designed to be a static class since it is not desirable to have multiple controllers.

\subsection{Download}
This class serves as a datatype to store all information regarding downloads from the libswift engine and as an interface to the libswift methods.
This information can be accessed by the DownloadManager, which publishes the information of all Downloads to the web interface via
the HttpServer class. This information can be retrieved by using libswift methods. Core functionality of this class is based on the libswift engine.
In that sense, it is a wrapper class which makes use of libswift methods.

\subsection{Stream}
This class serves as a datatype to store all information regarding streams from the swift engine and as interface to the libswift methods. It is in
essence the live-on-demand counterpart of the Download class, which is used to retrieve files from the Internet to store them on disk.
Since there will always be only one stream opened at a time (assuming that people only watch one film at the same time),
this class is designed according to the Singleton pattern.

\subsection{DownloadManager}
The DownloadManager, as the name implies, holds a list of Downloads and manages them. It can be accessed by the HttpServer, which controls this class whenever needed.
It retrieves information from all Downloads and calls the methods of the correct Download. The DownloadManager also manages the Stream class.
In order to save bandwidth, all Downloads are paused when a stream is opened. This is why the Stream class is also managed by the DownloadManager,
 because that way the DownloadManager is able to access both the Stream class and the Download class. For similar reasons as the HttpServer class, 
 the DownloadManager is designed to be a static class.

\subsection{SearchEngine}
This class serves as the interface to the search functionality developed by the Tribler team. It starts dispersie and DHT,
with which files can be sought on the net by calling the methods in the dispersie module. For similar reasons as the HttpServer class and DownloadManager class, 
this class is designed to be a static class.

\section{Dynamic models}

